<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>klImageCore: kl_ppm_image_io.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>kl_ppm_image_io.cpp</h1>  </div>
</div>
<div class="contents">
<a href="kl__ppm__image__io_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*******************************</span>
<a name="l00002"></a>00002 <span class="comment"> * Copyright (c) &lt;2007&gt;, &lt;Bruce Campbell&gt; All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  </span>
<a name="l00003"></a>00003 <span class="comment"> * Bruce B Campbell 11 30 2012  *</span>
<a name="l00004"></a>00004 <span class="comment"> ********************************/</span>
<a name="l00005"></a>00005 
<a name="l00006"></a>00006 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &lt;sstream&gt;</span>
<a name="l00011"></a>00011 
<a name="l00012"></a>00012 <span class="preprocessor">#include &quot;<a class="code" href="kl__image__io_8h.html">kl_image_io.h</a>&quot;</span>
<a name="l00013"></a>00013 
<a name="l00015"></a>00015 <span class="comment">//Only use this for unpadded buffers where linestride = width* precision * bands</span>
<a name="l00016"></a>00016     <span class="comment">//Write the ppm header </span>
<a name="l00017"></a>00017     <span class="comment">//PBM is for bitmaps (black and white, no grays)</span>
<a name="l00018"></a>00018     <span class="comment">//PGM is for grayscale</span>
<a name="l00019"></a>00019     <span class="comment">//PPM is for &quot;pixmaps&quot; which represent full RGB color.</span>
<a name="l00020"></a>00020     <span class="comment">//Each file starts with a two-byte file descriptor (in ASCII) that explains the type of file it is </span>
<a name="l00021"></a>00021     <span class="comment">//(PBM, PGM, and PPM) and its encoding (ASCII or binary). </span>
<a name="l00022"></a>00022     <span class="comment">//The descriptor is a capital P followed by a single digit number.</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024     <span class="comment">//File Descriptor Type Encoding </span>
<a name="l00025"></a>00025     <span class="comment">//P1 Portable bitmap ASCII </span>
<a name="l00026"></a>00026     <span class="comment">//P2 Portable graymap ASCII </span>
<a name="l00027"></a>00027     <span class="comment">//P3 Portable pixmap ASCII </span>
<a name="l00028"></a>00028     <span class="comment">//P4 Portable bitmap Binary </span>
<a name="l00029"></a>00029     <span class="comment">//P5 Portable graymap Binary </span>
<a name="l00030"></a>00030     <span class="comment">//P6 Portable pixmap Binary </span>
<a name="l00031"></a>00031 
<a name="l00032"></a><a class="code" href="ppm__helper_8h.html#abd4e33d1b3a2a25e1a64f8a52a101150">00032</a> <span class="keywordtype">void</span> <a class="code" href="kl__ppm__image__io_8cpp.html#abd4e33d1b3a2a25e1a64f8a52a101150">write_ppm</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename, <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * buf)
<a name="l00033"></a>00033 {
<a name="l00034"></a>00034     FILE * ppmfile;
<a name="l00035"></a>00035 
<a name="l00036"></a>00036     ppmfile = fopen (filename, <span class="stringliteral">&quot;wb&quot;</span>);
<a name="l00037"></a>00037 
<a name="l00038"></a>00038     <span class="keywordflow">if</span> (!ppmfile) 
<a name="l00039"></a>00039     {
<a name="l00040"></a>00040         std::stringstream ANSI_INFO_ss (std::stringstream::in | std::stringstream::out );
<a name="l00041"></a>00041         ANSI_INFO_ss&lt;&lt;<span class="stringliteral">&quot;ANSI COMPILE INFO: &quot;</span> &lt;&lt;__DATE__&lt;&lt;<span class="stringliteral">&quot;     &quot;</span>&lt;&lt;__TIME__&lt;&lt;<span class="stringliteral">&quot;   &quot;</span>&lt;&lt;__FILE__&lt;&lt;<span class="stringliteral">&quot;   &quot;</span>&lt;&lt;__LINE__&lt;&lt;<span class="stringliteral">&quot;       &quot;</span>&lt;&lt;std::endl;
<a name="l00042"></a>00042         std::string err = ANSI_INFO_ss.str();
<a name="l00043"></a>00043         err+=<span class="stringliteral">&quot; void write_ppm(char* filename, int width, int height, unsigned char * buf) :  Could not open file for writing PPM image data&quot;</span>;
<a name="l00044"></a>00044         <span class="keywordflow">throw</span> err;
<a name="l00045"></a>00045     }
<a name="l00046"></a>00046 
<a name="l00047"></a>00047     fprintf (ppmfile, <span class="stringliteral">&quot;P6\n%d %d\n255\n&quot;</span>, width, height);
<a name="l00048"></a>00048     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stepSize=3 * width;
<a name="l00049"></a>00049     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;height; i++)
<a name="l00050"></a>00050         fwrite (&amp;buf[i*stepSize], 3 * width, 1, ppmfile);
<a name="l00051"></a>00051 
<a name="l00052"></a>00052     flushall();
<a name="l00053"></a>00053     fclose(ppmfile);
<a name="l00054"></a>00054 }
<a name="l00055"></a>00055 
<a name="l00056"></a><a class="code" href="ppm__helper_8h.html#a59c449d0876be18f00f00c11a3e23836">00056</a> <span class="keywordtype">void</span> <a class="code" href="kl__ppm__image__io_8cpp.html#a59c449d0876be18f00f00c11a3e23836">write_ppm_single_band</a> (<span class="keyword">const</span> <span class="keywordtype">char</span>* filename, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> width,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> height, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * buf)
<a name="l00057"></a>00057 {
<a name="l00058"></a>00058     FILE * ppmfile;
<a name="l00059"></a>00059 
<a name="l00060"></a>00060     ppmfile = fopen (filename, <span class="stringliteral">&quot;wb&quot;</span>);
<a name="l00061"></a>00061 
<a name="l00062"></a>00062     <span class="keywordflow">if</span> (!ppmfile) 
<a name="l00063"></a>00063     {
<a name="l00064"></a>00064         std::stringstream ANSI_INFO_ss (std::stringstream::in | std::stringstream::out );
<a name="l00065"></a>00065         ANSI_INFO_ss&lt;&lt;<span class="stringliteral">&quot;ANSI COMPILE INFO: &quot;</span> &lt;&lt;__DATE__&lt;&lt;<span class="stringliteral">&quot;     &quot;</span>&lt;&lt;__TIME__&lt;&lt;<span class="stringliteral">&quot;   &quot;</span>&lt;&lt;__FILE__&lt;&lt;<span class="stringliteral">&quot;   &quot;</span>&lt;&lt;__LINE__&lt;&lt;<span class="stringliteral">&quot;       &quot;</span>&lt;&lt;std::endl;
<a name="l00066"></a>00066         std::string err = ANSI_INFO_ss.str();
<a name="l00067"></a>00067         err+=<span class="stringliteral">&quot; void write_ppm_single_band (const char* filename, unsigned int width,unsigned int height, unsigned char * buf) :  Could not open file for writing PPM image data&quot;</span>;
<a name="l00068"></a>00068         <span class="keywordflow">throw</span> err;
<a name="l00069"></a>00069     }
<a name="l00070"></a>00070 
<a name="l00071"></a>00071     fprintf (ppmfile, <span class="stringliteral">&quot;P5\n%d %d\n255\n&quot;</span>, width, height);
<a name="l00072"></a>00072     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stepSize=1 * width;
<a name="l00073"></a>00073     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;height; i++)
<a name="l00074"></a>00074         fwrite (&amp;buf[i*stepSize], 1 * width, 1, ppmfile);
<a name="l00075"></a>00075     flushall();
<a name="l00076"></a>00076     fclose(ppmfile);
<a name="l00077"></a>00077 }
<a name="l00078"></a>00078 
<a name="l00079"></a><a class="code" href="ppm__helper_8h.html#a4e631bab8c488b3cdb27e6829a66a8a7">00079</a> <span class="keywordtype">bool</span> <a class="code" href="kl__ppm__image__io_8cpp.html#a4e631bab8c488b3cdb27e6829a66a8a7">read_ppm</a> (<span class="keyword">const</span> <span class="keywordtype">char</span>* filename,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> width,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> height,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bands, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * inputbuf)
<a name="l00080"></a>00080 {
<a name="l00081"></a>00081     FILE * ppmfile;
<a name="l00082"></a>00082 
<a name="l00083"></a>00083     ppmfile = fopen (filename, <span class="stringliteral">&quot;rb&quot;</span>);
<a name="l00084"></a>00084 
<a name="l00085"></a>00085     <span class="keywordflow">if</span> (!ppmfile) 
<a name="l00086"></a>00086     {
<a name="l00087"></a>00087         std::stringstream ANSI_INFO_ss (std::stringstream::in | std::stringstream::out );
<a name="l00088"></a>00088         ANSI_INFO_ss&lt;&lt;<span class="stringliteral">&quot;ANSI COMPILE INFO: &quot;</span> &lt;&lt;__DATE__&lt;&lt;<span class="stringliteral">&quot;     &quot;</span>&lt;&lt;__TIME__&lt;&lt;<span class="stringliteral">&quot;   &quot;</span>&lt;&lt;__FILE__&lt;&lt;<span class="stringliteral">&quot;   &quot;</span>&lt;&lt;__LINE__&lt;&lt;<span class="stringliteral">&quot;       &quot;</span>&lt;&lt;std::endl;
<a name="l00089"></a>00089         std::string err = ANSI_INFO_ss.str();
<a name="l00090"></a>00090         err+=<span class="stringliteral">&quot;bool read_ppm (const char* filename,unsigned int width,unsigned int height,unsigned int bands, unsigned char * inputbuf) :  Could not open file for reading PPM image data&quot;</span>;
<a name="l00091"></a>00091         <span class="keywordflow">throw</span> err;
<a name="l00092"></a>00092     }
<a name="l00093"></a>00093     FILE* pf=ppmfile;
<a name="l00094"></a>00094     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> PPMREADBUFLEN = 256;
<a name="l00095"></a>00095     <span class="keywordtype">char</span> buf[256];
<a name="l00096"></a>00096     <span class="keywordtype">char</span> * t;   
<a name="l00097"></a>00097     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> w, h, d;  
<a name="l00098"></a>00098     <span class="keywordtype">int</span> r;         
<a name="l00099"></a>00099     <span class="keywordflow">if</span> (pf == NULL) 
<a name="l00100"></a>00100     {
<a name="l00101"></a>00101         <span class="keywordflow">return</span> NULL;
<a name="l00102"></a>00102     } 
<a name="l00103"></a>00103     t = fgets(buf, PPMREADBUFLEN, pf); 
<a name="l00104"></a>00104     <span class="keywordflow">if</span> ( (t == NULL) || ( strncmp(buf, <span class="stringliteral">&quot;P6\n&quot;</span>, 3) != 0 ) )
<a name="l00105"></a>00105     {
<a name="l00106"></a>00106         <span class="keywordflow">return</span> NULL; 
<a name="l00107"></a>00107     }
<a name="l00108"></a>00108 
<a name="l00109"></a>00109     <span class="keywordflow">do</span>        
<a name="l00110"></a>00110     { <span class="comment">/* Px formats can have # comments after first line */</span>    
<a name="l00111"></a>00111         t = fgets(buf, PPMREADBUFLEN, pf);        
<a name="l00112"></a>00112         <span class="keywordflow">if</span> ( t == NULL )
<a name="l00113"></a>00113             <span class="keywordflow">return</span> NULL; 
<a name="l00114"></a>00114     } 
<a name="l00115"></a>00115     <span class="keywordflow">while</span> ( strncmp(buf, <span class="stringliteral">&quot;#&quot;</span>, 1) == 0 );     
<a name="l00116"></a>00116     r = sscanf(buf, <span class="stringliteral">&quot;%u %u&quot;</span>, &amp;w, &amp;h);   
<a name="l00117"></a>00117     <span class="keywordflow">if</span> ( r &lt; 2 )
<a name="l00118"></a>00118         <span class="keywordflow">return</span> NULL;       
<a name="l00119"></a>00119     <span class="comment">// The program fails if the first byte of the image is equal to 32. because </span>
<a name="l00120"></a>00120     <span class="comment">// the fscanf eats the space and the image is read with some bit less     </span>
<a name="l00121"></a>00121     r = fscanf(pf, <span class="stringliteral">&quot;%u\n&quot;</span>, &amp;d);  
<a name="l00122"></a>00122     <span class="keywordflow">if</span> ( (r &lt; 1) || ( d != 255 ) ) <span class="keywordflow">return</span> NULL;  
<a name="l00123"></a>00123     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* imagebuf =inputbuf;
<a name="l00124"></a>00124     <span class="keywordtype">size_t</span> rd;
<a name="l00125"></a>00125     <span class="keywordflow">if</span> ( imagebuf != NULL )    
<a name="l00126"></a>00126     {       
<a name="l00127"></a>00127         rd = fread(imagebuf, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>), w*h*3, pf);   
<a name="l00128"></a>00128     }
<a name="l00129"></a>00129     <span class="keywordflow">if</span> ( rd &lt; w*h )       
<a name="l00130"></a>00130     {           
<a name="l00131"></a>00131         <span class="keyword">delete</span> imagebuf;      
<a name="l00132"></a>00132         <span class="keywordflow">return</span> NULL;      
<a name="l00133"></a>00133     }          
<a name="l00134"></a>00134     flushall();
<a name="l00135"></a>00135     fclose(ppmfile);
<a name="l00136"></a>00136 }<span class="comment">//Only use this for unpadded buffers where linestride = width* precision * bands</span>
<a name="l00137"></a><a class="code" href="ppm__helper_8h.html#a3453a753c60d966d35724298d6118a7c">00137</a> <span class="keywordtype">bool</span> <a class="code" href="kl__ppm__image__io_8cpp.html#a3453a753c60d966d35724298d6118a7c">query_ppm</a> (<span class="keyword">const</span> <span class="keywordtype">char</span>* filename,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;width,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;height,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;bands)
<a name="l00138"></a>00138 {
<a name="l00139"></a>00139     FILE * ppmfile;
<a name="l00140"></a>00140 
<a name="l00141"></a>00141     ppmfile = fopen (filename, <span class="stringliteral">&quot;rb&quot;</span>);
<a name="l00142"></a>00142 
<a name="l00143"></a>00143     <span class="keywordflow">if</span> (!ppmfile) 
<a name="l00144"></a>00144     {
<a name="l00145"></a>00145         std::stringstream ANSI_INFO_ss (std::stringstream::in | std::stringstream::out );
<a name="l00146"></a>00146         ANSI_INFO_ss&lt;&lt;<span class="stringliteral">&quot;ANSI COMPILE INFO: &quot;</span> &lt;&lt;__DATE__&lt;&lt;<span class="stringliteral">&quot;     &quot;</span>&lt;&lt;__TIME__&lt;&lt;<span class="stringliteral">&quot;   &quot;</span>&lt;&lt;__FILE__&lt;&lt;<span class="stringliteral">&quot;   &quot;</span>&lt;&lt;__LINE__&lt;&lt;<span class="stringliteral">&quot;       &quot;</span>&lt;&lt;std::endl;
<a name="l00147"></a>00147         std::string err = ANSI_INFO_ss.str();
<a name="l00148"></a>00148         err+=<span class="stringliteral">&quot;bool query_ppm (const char* filename,unsigned int &amp;width,unsigned int &amp;height,unsigned int &amp;bands):  Could not open file for querying PPM image data&quot;</span>;
<a name="l00149"></a>00149         <span class="keywordflow">throw</span> err;
<a name="l00150"></a>00150     }
<a name="l00151"></a>00151     <span class="comment">//Read the ppm header </span>
<a name="l00152"></a>00152     <span class="comment">//PBM is for bitmaps (black and white, no grays)</span>
<a name="l00153"></a>00153     <span class="comment">//PGM is for grayscale</span>
<a name="l00154"></a>00154     <span class="comment">//PPM is for &quot;pixmaps&quot; which represent full RGB color.</span>
<a name="l00155"></a>00155     <span class="comment">//Each file starts with a two-byte file descriptor (in ASCII) that explains the type of file it is </span>
<a name="l00156"></a>00156     <span class="comment">//(PBM, PGM, and PPM) and its encoding (ASCII or binary). </span>
<a name="l00157"></a>00157     <span class="comment">//The descriptor is a capital P followed by a single digit number.</span>
<a name="l00158"></a>00158 
<a name="l00159"></a>00159     <span class="comment">//File Descriptor Type Encoding </span>
<a name="l00160"></a>00160     <span class="comment">//P1 Portable bitmap ASCII </span>
<a name="l00161"></a>00161     <span class="comment">//P2 Portable graymap ASCII </span>
<a name="l00162"></a>00162     <span class="comment">//P3 Portable pixmap ASCII </span>
<a name="l00163"></a>00163     <span class="comment">//P4 Portable bitmap Binary </span>
<a name="l00164"></a>00164     <span class="comment">//P5 Portable graymap Binary </span>
<a name="l00165"></a>00165     <span class="comment">//P6 Portable pixmap Binary </span>
<a name="l00166"></a>00166     FILE* pf=ppmfile;
<a name="l00167"></a>00167     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> PPMREADBUFLEN = 1024;
<a name="l00168"></a>00168     <span class="keywordtype">char</span> buf[1024];
<a name="l00169"></a>00169     <span class="keywordtype">char</span> * t;   
<a name="l00170"></a>00170     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> w, h, d;  
<a name="l00171"></a>00171     <span class="keywordtype">int</span> r;         
<a name="l00172"></a>00172     <span class="keywordflow">if</span> (pf == NULL) 
<a name="l00173"></a>00173     {
<a name="l00174"></a>00174         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00175"></a>00175     } 
<a name="l00176"></a>00176     t = fgets(buf, PPMREADBUFLEN, pf); 
<a name="l00177"></a>00177     <span class="keywordflow">if</span> ( (t == NULL) || ( strncmp(buf, <span class="stringliteral">&quot;P6\n&quot;</span>, 3) != 0 ) )
<a name="l00178"></a>00178     {
<a name="l00179"></a>00179         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00180"></a>00180     }
<a name="l00181"></a>00181 
<a name="l00182"></a>00182     <span class="keywordflow">do</span>        
<a name="l00183"></a>00183     { <span class="comment">/* Px formats can have # comments after first line */</span>    
<a name="l00184"></a>00184         t = fgets(buf, PPMREADBUFLEN, pf);        
<a name="l00185"></a>00185         <span class="keywordflow">if</span> ( t == NULL )
<a name="l00186"></a>00186         {
<a name="l00187"></a>00187             <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l00188"></a>00188         }
<a name="l00189"></a>00189     } 
<a name="l00190"></a>00190     <span class="keywordflow">while</span> ( strncmp(buf, <span class="stringliteral">&quot;#&quot;</span>, 1) == 0 );     
<a name="l00191"></a>00191     r = sscanf(buf, <span class="stringliteral">&quot;%u %u&quot;</span>, &amp;w, &amp;h);   
<a name="l00192"></a>00192     <span class="keywordflow">if</span> ( r &lt; 2 )
<a name="l00193"></a>00193     {
<a name="l00194"></a>00194         <span class="keywordflow">return</span> <span class="keyword">false</span>;       
<a name="l00195"></a>00195     }
<a name="l00196"></a>00196     <span class="comment">// The program fails if the first byte of the image is equal to 32. because </span>
<a name="l00197"></a>00197     <span class="comment">// the fscanf eats the space and the image is read with some bit less     </span>
<a name="l00198"></a>00198     r = fscanf(pf, <span class="stringliteral">&quot;%u\n&quot;</span>, &amp;d);  
<a name="l00199"></a>00199     <span class="keywordflow">if</span> ( (r &lt; 1) || ( d != 255 ) ) 
<a name="l00200"></a>00200     {
<a name="l00201"></a>00201         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00202"></a>00202     }
<a name="l00203"></a>00203 
<a name="l00204"></a>00204     width=w;
<a name="l00205"></a>00205     height=h;
<a name="l00206"></a>00206     bands=3;
<a name="l00207"></a>00207 
<a name="l00208"></a>00208     flushall();
<a name="l00209"></a>00209     fclose(ppmfile);
<a name="l00210"></a>00210     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00211"></a>00211 
<a name="l00212"></a>00212 
<a name="l00213"></a>00213 }
<a name="l00214"></a>00214 
<a name="l00215"></a><a class="code" href="ppm__helper_8h.html#a948651f4c9ecb7521a3833b15176b22c">00215</a> <span class="keywordtype">void</span> <a class="code" href="kl__ppm__image__io_8cpp.html#abd4e33d1b3a2a25e1a64f8a52a101150">write_ppm</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename, <a class="code" href="kl__image__buffer_8h.html#ae411c8671aea3ca24d160c5c58aafd88">klRasterBufferPointer</a> klrbp)
<a name="l00216"></a>00216 {
<a name="l00217"></a>00217     <span class="keywordtype">int</span> width=klrbp-&gt;width(); 
<a name="l00218"></a>00218     <span class="keywordtype">int</span> height=klrbp-&gt;height(); 
<a name="l00219"></a>00219     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * buf=klrbp-&gt;buffer();
<a name="l00220"></a>00220     FILE * ppmfile;
<a name="l00221"></a>00221 
<a name="l00222"></a>00222     ppmfile = fopen (filename, <span class="stringliteral">&quot;wb&quot;</span>);
<a name="l00223"></a>00223 
<a name="l00224"></a>00224     <span class="keywordflow">if</span> (!ppmfile) 
<a name="l00225"></a>00225     {
<a name="l00226"></a>00226         std::stringstream ANSI_INFO_ss (std::stringstream::in | std::stringstream::out );
<a name="l00227"></a>00227         ANSI_INFO_ss&lt;&lt;<span class="stringliteral">&quot;ANSI COMPILE INFO: &quot;</span> &lt;&lt;__DATE__&lt;&lt;<span class="stringliteral">&quot;     &quot;</span>&lt;&lt;__TIME__&lt;&lt;<span class="stringliteral">&quot;   &quot;</span>&lt;&lt;__FILE__&lt;&lt;<span class="stringliteral">&quot;   &quot;</span>&lt;&lt;__LINE__&lt;&lt;<span class="stringliteral">&quot;       &quot;</span>&lt;&lt;std::endl;
<a name="l00228"></a>00228         std::string err = ANSI_INFO_ss.str();
<a name="l00229"></a>00229         err+=<span class="stringliteral">&quot;void write_ppm(char* filename, klRasterBufferPointer klrbp):  Could not open file for writing PPM image data&quot;</span>;
<a name="l00230"></a>00230         <span class="keywordflow">throw</span> err;
<a name="l00231"></a>00231 
<a name="l00232"></a>00232     }
<a name="l00233"></a>00233 
<a name="l00234"></a>00234     fprintf (ppmfile, <span class="stringliteral">&quot;P6\n%d %d\n255\n&quot;</span>, width, height);
<a name="l00235"></a>00235     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stepSize=klrbp-&gt;yStride();
<a name="l00236"></a>00236     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;height; i++)
<a name="l00237"></a>00237         fwrite (&amp;buf[i*stepSize], 3 * width, 1, ppmfile);
<a name="l00238"></a>00238 
<a name="l00239"></a>00239     flushall();
<a name="l00240"></a>00240     fclose(ppmfile);
<a name="l00241"></a>00241 }
<a name="l00242"></a>00242 
<a name="l00243"></a><a class="code" href="ppm__helper_8h.html#a0b224a57ad9e72bcb2d6b49051568d4c">00243</a> <span class="keywordtype">void</span> <a class="code" href="kl__ppm__image__io_8cpp.html#a59c449d0876be18f00f00c11a3e23836">write_ppm_single_band</a> (<span class="keyword">const</span> <span class="keywordtype">char</span>* filename,<a class="code" href="kl__image__buffer_8h.html#ae411c8671aea3ca24d160c5c58aafd88">klRasterBufferPointer</a> klrbp)
<a name="l00244"></a>00244 { 
<a name="l00245"></a>00245     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> width=klrbp-&gt;width();
<a name="l00246"></a>00246     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> height=klrbp-&gt;height();
<a name="l00247"></a>00247     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * buf=klrbp-&gt;buffer();
<a name="l00248"></a>00248     FILE * ppmfile;
<a name="l00249"></a>00249 
<a name="l00250"></a>00250     ppmfile = fopen (filename, <span class="stringliteral">&quot;wb&quot;</span>);
<a name="l00251"></a>00251 
<a name="l00252"></a>00252     <span class="keywordflow">if</span> (!ppmfile) 
<a name="l00253"></a>00253     {
<a name="l00254"></a>00254         std::stringstream ANSI_INFO_ss (std::stringstream::in | std::stringstream::out );
<a name="l00255"></a>00255         ANSI_INFO_ss&lt;&lt;<span class="stringliteral">&quot;ANSI COMPILE INFO: &quot;</span> &lt;&lt;__DATE__&lt;&lt;<span class="stringliteral">&quot;     &quot;</span>&lt;&lt;__TIME__&lt;&lt;<span class="stringliteral">&quot;   &quot;</span>&lt;&lt;__FILE__&lt;&lt;<span class="stringliteral">&quot;   &quot;</span>&lt;&lt;__LINE__&lt;&lt;<span class="stringliteral">&quot;       &quot;</span>&lt;&lt;std::endl;
<a name="l00256"></a>00256         std::string err = ANSI_INFO_ss.str();
<a name="l00257"></a>00257         err+=<span class="stringliteral">&quot;void write_ppm_single_band (const char* filename,klRasterBufferPointer klrbp):  Could not open file for writing PPM image data&quot;</span>;
<a name="l00258"></a>00258         <span class="keywordflow">throw</span> err;
<a name="l00259"></a>00259     }
<a name="l00260"></a>00260 
<a name="l00261"></a>00261     fprintf (ppmfile, <span class="stringliteral">&quot;P5\n%d %d\n255\n&quot;</span>, width, height);
<a name="l00262"></a>00262     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stepSize=0;
<a name="l00263"></a>00263     <span class="keywordflow">if</span>(klrbp-&gt;numBands()==1)
<a name="l00264"></a>00264         stepSize=klrbp-&gt;yStride();
<a name="l00265"></a>00265     <span class="keywordflow">else</span>
<a name="l00266"></a>00266     {
<a name="l00267"></a>00267         std::stringstream ANSI_INFO_ss (std::stringstream::in | std::stringstream::out );
<a name="l00268"></a>00268         ANSI_INFO_ss&lt;&lt;<span class="stringliteral">&quot;ANSI COMPILE INFO: &quot;</span> &lt;&lt;__DATE__&lt;&lt;<span class="stringliteral">&quot;     &quot;</span>&lt;&lt;__TIME__&lt;&lt;<span class="stringliteral">&quot;   &quot;</span>&lt;&lt;__FILE__&lt;&lt;<span class="stringliteral">&quot;   &quot;</span>&lt;&lt;__LINE__&lt;&lt;<span class="stringliteral">&quot;       &quot;</span>&lt;&lt;std::endl;
<a name="l00269"></a>00269         std::string err = ANSI_INFO_ss.str();
<a name="l00270"></a>00270         err+=<span class="stringliteral">&quot;void write_ppm_single_band (const char* filename,klRasterBufferPointer klrbp):  Image buffer is not single band.&quot;</span>;
<a name="l00271"></a>00271         <span class="keywordflow">throw</span> err;
<a name="l00272"></a>00272     }
<a name="l00273"></a>00273     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;height; i++)
<a name="l00274"></a>00274         fwrite (&amp;buf[i*stepSize], 1 * width, 1, ppmfile);
<a name="l00275"></a>00275     flushall();
<a name="l00276"></a>00276     fclose(ppmfile);
<a name="l00277"></a>00277 }
<a name="l00278"></a>00278 
<a name="l00279"></a>00279 
<a name="l00280"></a>00280 
<a name="l00281"></a>00281 
<a name="l00282"></a>00282 
<a name="l00283"></a>00283 
<a name="l00284"></a>00284 
<a name="l00285"></a>00285 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Apr 21 2014 10:04:36 for klImageCore by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
