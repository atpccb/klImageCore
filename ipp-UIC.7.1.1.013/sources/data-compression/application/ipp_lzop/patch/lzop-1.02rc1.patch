diff -rupN lzop-1.02rc1/.patch lzop-1.02rc1/.patch
--- lzop-1.02rc1/.patch	1970-01-01 03:00:00.000000000 -0400
+++ lzop-1.02rc1/.patch	2012-05-30 10:02:49.299946000 +0755
@@ -0,0 +1 @@
+.
diff -rupN lzop-1.02rc1/src/compress.c lzop-1.02rc1/src/compress.c
--- lzop-1.02rc1/src/compress.c	2005-07-25 18:26:39.000000000 +0400
+++ lzop-1.02rc1/src/compress.c	2012-05-30 10:02:49.309932000 +0755
@@ -52,6 +52,11 @@ int x_set_method(int m, int l)
     if (r >= 0)
         return r;
 #endif
+#if defined(WITH_IPP_LZO)
+    r = ipp_lzo_set_method(m, l);
+    if(r >=0)
+        return r;
+#endif
 
     UNUSED(r);
     return -1;
@@ -67,6 +72,11 @@ int x_get_method(header_t *h)
     if (r >= 0)
         return r;
 #endif
+#if defined(WITH_IPP_LZO)
+    r = ipp_lzo_get_method(h);
+    if (r >= 0)
+        return r;
+#endif
 #if defined(WITH_NRV)
     r = nrv_get_method(h);
     if (r >= 0)
@@ -101,6 +111,9 @@ lzo_bool x_enter(const header_t *h)
 #if defined(WITH_ZLIB)
         ok &= zlib_enter(NULL);
 #endif
+#if defined(WITH_IPP_LZO)
+        ok &= ipp_lzo_enter(NULL);
+#endif
         return ok;
     }
 
@@ -123,6 +136,10 @@ lzo_bool x_enter(const header_t *h)
     case M_ZLIB:
         return zlib_enter(h);
 #endif
+#if defined(WITH_IPP_LZO)
+    case M_IPP:
+        return ipp_lzo_enter(h);
+#endif
     }
     return 0;
 }
@@ -141,6 +158,9 @@ void x_leave(const header_t *h)
 #if defined(WITH_LZO)
         lzo_leave(NULL);
 #endif
+#if defined(WITH_IPP_LZO)
+        ipp_lzo_leave(NULL);
+#endif
         return;
     }
 
@@ -153,6 +173,11 @@ void x_leave(const header_t *h)
         lzo_leave(h);
         break;
 #endif
+#if defined(WITH_IPP_LZO)
+    case M_IPP:
+        ipp_lzo_leave(h);
+        break;
+#endif
 #if defined(WITH_NRV)
     case M_NRV1A:
     case M_NRV1B:
@@ -188,6 +213,11 @@ lzo_bool x_compress(file_t *fip, file_t 
         lzo_init_compress_header(h);
         break;
 #endif
+#if defined(WITH_IPP_LZO)
+    case M_IPP:
+        ipp_lzo_init_compress_header(h);
+        break;
+#endif
 #if defined(WITH_NRV)
     case M_NRV1A:
     case M_NRV1B:
@@ -232,6 +262,11 @@ lzo_bool x_compress(file_t *fip, file_t 
         ok = lzo_compress(fip,fop,h);
         break;
 #endif
+#if defined(WITH_IPP_LZO)
+    case M_IPP:
+        ok = ipp_lzo_compress(fip, fop, h);
+        break;
+#endif
 #if defined(WITH_NRV)
     case M_NRV1A:
     case M_NRV1B:
@@ -315,6 +350,11 @@ lzo_bool x_decompress(file_t *fip, file_
         ok = lzo_decompress(fip,fop,h,skip);
         break;
 #endif
+#if defined(WITH_IPP_LZO)
+    case M_IPP:
+        ok = ipp_lzo_decompress(fip, fop, h, skip);
+        break;
+#endif
 #if defined(WITH_NRV)
     case M_NRV1A:
     case M_NRV1B:
diff -rupN lzop-1.02rc1/src/conf.h lzop-1.02rc1/src/conf.h
--- lzop-1.02rc1/src/conf.h	2005-07-25 18:26:39.000000000 +0400
+++ lzop-1.02rc1/src/conf.h	2012-05-30 10:02:49.316950000 +0755
@@ -361,7 +361,9 @@ enum {
     M_NRV2B       =  0x2b,
     M_NRV2D       =  0x2d,
     M_ZLIB        =   128,
-
+#if defined(WITH_IPP_LZO)
+    M_IPP         =  0x3a,
+#endif
     M_UNUSED
 };
 
@@ -565,6 +567,18 @@ int lzo_set_method(int m, int l);
 void lzo_init_compress_header(header_t *h);
 
 #endif
+#if defined(WITH_IPP_LZO)
+extern int opt_show_clocks;
+lzo_bool ipp_lzo_enter(const header_t *h);
+void ipp_lzo_leave(const header_t *h);
+
+lzo_bool ipp_lzo_compress(file_t *fip, file_t *fop, const header_t *h);
+lzo_bool ipp_lzo_decompress(file_t *fip, file_t *fop, const header_t *h, lzo_bool skip);
+
+int ipp_lzo_get_method(header_t *h);
+int ipp_lzo_set_method(int m, int l);
+void ipp_lzo_init_compress_header(header_t *h);
+#endif
 
 
 /*************************************************************************
diff -rupN lzop-1.02rc1/src/help.c lzop-1.02rc1/src/help.c
--- lzop-1.02rc1/src/help.c	2005-07-25 18:26:39.000000000 +0400
+++ lzop-1.02rc1/src/help.c	2012-05-30 10:02:49.323958000 +0755
@@ -28,6 +28,9 @@
 
 #include "conf.h"
 #include "version.h"
+#if defined(WITH_IPP_LZO)
+#include <ipp.h>
+#endif
 
 
 /*************************************************************************
@@ -201,19 +204,35 @@ void version(void)
         pp[i] = (char) *qq;
     pp[i] = 0;
     p = strstr(pp,"LZO version");
-    if (p == NULL)
-        return;
-    s = strchr(p,'$');
-    if (s == NULL)
-        return;
-    for (q = s; q > p && q[-1] == '\n'; )
-        *--q = 0;
-    q = strchr(s+1,'$');
-    if (q == NULL)
-        return;
-    q[1] = 0;
-    con_fprintf(f,"\n%s\n",p);
-    con_fprintf(f,"\n%s\n",s);
+    if (p != NULL) {
+        s = strchr(p,'$');
+        if (s != NULL) {
+            for (q = s; q > p && q[-1] == '\n'; )
+                *--q = 0;
+            q = strchr(s+1,'$');
+            if (q != NULL) {
+                q[1] = 0;
+                con_fprintf(f,"\n%s\n",p);
+                con_fprintf(f,"\n%s\n",s);
+            }
+        }
+    }
+#if defined(WITH_IPP_LZO)
+    {
+        const IppLibraryVersion *libcore = ippGetLibVersion();
+        const IppLibraryVersion *libs = ippsGetLibVersion();
+        const IppLibraryVersion *libdc = ippdcGetLibVersion();
+        const char* lib_fmt = "%-26s %-15s %-15s %d.%d.%d.%d\n";
+
+        con_fprintf(f, "\n");
+        con_fprintf(f, lib_fmt, "IPP Core lib", libcore->Name, libcore->Version, libcore->major, 
+            libcore->minor, libcore->majorBuild, libcore->build);
+        con_fprintf(f, lib_fmt, "IPP Signal lib", libs->Name, libs->Version, libs->major, 
+            libs->minor, libs->majorBuild, libs->build);
+        con_fprintf(f, lib_fmt, "IPP Data Compression lib", libdc->Name, libdc->Version, libdc->major, 
+            libdc->minor, libdc->majorBuild, libdc->build);
+    }
+#endif
 }
 
 
diff -rupN lzop-1.02rc1/src/lzop.c lzop-1.02rc1/src/lzop.c
--- lzop-1.02rc1/src/lzop.c	2005-07-25 18:26:39.000000000 +0400
+++ lzop-1.02rc1/src/lzop.c	2012-05-30 10:17:59.847568000 +0755
@@ -30,6 +30,9 @@
 #include "version.h"
 #include "mygetopt.h"
 
+#if defined(WITH_IPP_LZO)
+#include <ippcore.h>
+#endif
 
 /*************************************************************************
 // options
@@ -67,6 +70,9 @@ lzo_bool opt_stdout = 0;
 char opt_suffix[1+SUFFIX_MAX+1] = { 0 };
 lzo_bool opt_unlink = 0;
 int opt_verbose = 1;
+#if defined(WITH_IPP_LZO)
+int opt_show_clocks = 0;
+#endif
 
 static int done_output_name = 0;
 static int done_output_path = 0;
@@ -2676,6 +2682,16 @@ static int do_option(int optc)
             e_usage();
         break;
 #endif
+#if defined(WITH_IPP_LZO)
+    case 900:
+    case 901:
+        if (!set_method(M_IPP, optc-850))
+            e_usage();
+        break;
+    case 902:
+        opt_show_clocks = 1;
+        break;
+#endif
 
     case 521:
         if (!(mfx_optarg && isdigit(mfx_optarg[0])))
@@ -2733,6 +2749,11 @@ static const struct mfx_option longopts[
     {"nrv2a",   0x22, 0, 813},
     {"nrv2b",   0x22, 0, 814},
 #endif
+#if defined(WITH_IPP_LZO)
+    {"ipplzost", 0x33, 0, 900},
+    {"ipplzomt", 0x33, 0, 901},
+    {"show-clocks", 0x33, 0, 902},
+#endif
 #if defined(WITH_ZLIB)
     {"zlib",    0x22, 0, 801},
 #endif
@@ -3063,6 +3084,9 @@ int main(int argc, char *argv[])
     assert(STDOUT_FILENO >= 0);
     assert(STDERR_FILENO >= 0);
 
+#if defined(WITH_IPP_LZO)
+    ippStaticInit();
+#endif
     f_init();
     first_options(argc,argv);
 #if defined(OPTIONS_VAR)
diff -rupN lzop-1.02rc1/src/miniacc.h lzop-1.02rc1/src/miniacc.h
--- lzop-1.02rc1/src/miniacc.h	2005-07-25 18:26:39.000000000 +0400
+++ lzop-1.02rc1/src/miniacc.h	2012-05-30 10:02:49.364956000 +0755
@@ -1976,7 +1976,7 @@ extern "C" {
 #    undef HAVE_VSNPRINTF
 #  else
 #    define snprintf _snprintf
-#    define vsnprintf _vsnprintf
+/* #    define vsnprintf _vsnprintf */ /* Commented for VS2008 compiler */
 #  endif
 #  if ((_MSC_VER < 800) && ACC_OS_WIN16)
 #    undef HAVE_ALLOCA
diff -rupN lzop-1.02rc1/src/p_lzo.c lzop-1.02rc1/src/p_lzo.c
--- lzop-1.02rc1/src/p_lzo.c	2005-07-25 18:26:39.000000000 +0400
+++ lzop-1.02rc1/src/p_lzo.c	2012-05-30 10:02:49.375937000 +0755
@@ -29,9 +29,13 @@
 #include "conf.h"
 
 
+#if defined(WITH_IPP_LZO)
+#include <ipp.h>
+#endif
 #if defined(WITH_LZO)
 
 
+
 /*************************************************************************
 //
 **************************************************************************/
@@ -280,6 +284,10 @@ lzo_bool lzo_compress(file_t *fip, file_
     lzo_uint32 c_crc32 = CRC32_INIT_VALUE, d_crc32 = CRC32_INIT_VALUE;
     lzo_int l;
     lzo_bool ok = 1;
+#if defined(WITH_IPP_LZO)
+    Ipp64u total_clocks = 0;
+    Ipp64u start;
+#endif
 
     for (;;)
     {
@@ -295,14 +303,23 @@ lzo_bool lzo_compress(file_t *fip, file_
             break;
 
         /* compute checksum of uncompressed block */
+#if defined(WITH_IPP_LZO)
+        start = ippGetCpuClocks();
+#endif
         if (h->flags & F_ADLER32_D)
             d_adler32 = lzo_adler32(ADLER32_INIT_VALUE,b1,src_len);
         if (h->flags & F_CRC32_D)
             d_crc32 = lzo_crc32(CRC32_INIT_VALUE,b1,src_len);
+#if defined(WITH_IPP_LZO)
+        total_clocks += ippGetCpuClocks() - start;
+#endif
 
         x_filter(b1,src_len,h);
 
         /* compress */
+#if defined(WITH_IPP_LZO)
+        start = ippGetCpuClocks();
+#endif
         if (h->method == M_LZO1X_1)
             r = lzo1x_1_compress(b1, src_len, b2, &dst_len, wrkmem.mb_mem);
 #if defined(USE_LZO1X_1_15)
@@ -319,6 +336,9 @@ lzo_bool lzo_compress(file_t *fip, file_
         else
             fatal(fip,"Internal error");
 
+#if defined(WITH_IPP_LZO)
+        total_clocks += ippGetCpuClocks() - start;
+#endif
 #if 0
         fprintf(stderr, "%ld %ld %ld\n", (long)src_len, (long)dst_len, (long)block2.size);
 #endif
@@ -365,7 +385,11 @@ lzo_bool lzo_compress(file_t *fip, file_
         else
             write_buf(fop,b1,src_len);
     }
-
+#if defined(WITH_IPP_LZO)
+    if (opt_show_clocks) {
+        printf( "total_clocks = %llu\n", total_clocks );
+    }
+#endif
     return ok;
 }
 
@@ -386,6 +410,10 @@ lzo_bool lzo_decompress(file_t *fip, fil
     mblock_t * const block = &blocks[1];
     lzo_bytep b1;
     lzo_bytep const b2 = block->mb_mem;
+#if defined(WITH_IPP_LZO)
+    Ipp64u total_clocks = 0;
+    Ipp64u start;
+#endif
 
     use_seek = skip || opt_cmd == CMD_LIST || opt_cmd == CMD_LS ||
                        opt_cmd == CMD_INFO;
@@ -512,11 +540,17 @@ lzo_bool lzo_decompress(file_t *fip, fil
             lzo_uint d = dst_len;
 
             /* decompress */
+#if defined(WITH_IPP_LZO)
+            start = ippGetCpuClocks();
+#endif
             if (opt_decompress_safe)
                 r = lzo1x_decompress_safe(b1,src_len,b2,&d,NULL);
             else
                 r = lzo1x_decompress(b1,src_len,b2,&d,NULL);
 
+#if defined(WITH_IPP_LZO)
+            total_clocks += ippGetCpuClocks() - start;
+#endif
             if (r != LZO_E_OK || dst_len != d)
             {
                 error(fip,"Compressed data violation");
@@ -536,6 +570,9 @@ lzo_bool lzo_decompress(file_t *fip, fil
         x_filter(dst,dst_len,h);
 
         /* verify checksum of uncompressed block */
+#if defined(WITH_IPP_LZO)
+        start = ippGetCpuClocks();
+#endif
         if (opt_checksum && (h->flags & F_ADLER32_D))
         {
             lzo_uint32 c;
@@ -556,11 +593,19 @@ lzo_bool lzo_decompress(file_t *fip, fil
                 ok = 0; break;
             }
         }
+#if defined(WITH_IPP_LZO)
+        total_clocks += ippGetCpuClocks() - start;
+#endif
 
         /* write uncompressed block data */
         write_buf(fop,dst,dst_len);
         fop->bytes_processed += dst_len;
     }
+#if defined(WITH_IPP_LZO)
+    if (opt_show_clocks) {
+        printf( "total_clocks = %llu\n", total_clocks );
+    }
+#endif
 
     return ok;
 }
@@ -568,7 +613,434 @@ lzo_bool lzo_decompress(file_t *fip, fil
 
 #endif /* WITH_LZO */
 
+#if defined(WITH_IPP_LZO)
+static IppLZOState_8u *p_lzo_state = NULL;
+static Ipp8u* p_in_buffer = NULL;
+static Ipp32u in_len = 0;
+static Ipp8u* p_out_buffer = NULL;
+static Ipp32u out_len = 0;
+
+int ipp_lzo_set_method(int m, int level)
+{
+    opt_method = m;
+    opt_level = level;
+    if (opt_level != 50 && opt_level != 51) {
+        return 1; /* Error, not ST or MT is asked*/
+    }
+    return 0;
+}
+lzo_bool ipp_lzo_enter(const header_t *h)
+{
+    Ipp32u lzo_struct_size;
+    IppStatus ipp_status;
+
+    if (h != NULL) {
+        return 1;
+    }
+    ipp_status = ippsEncodeLZOGetSize((opt_level>50)? IppLZO1XMT:IppLZO1XST, (Ipp32u)block_size, &lzo_struct_size);
+    if (ipp_status != ippStsNoErr)
+            return 0;
+    p_lzo_state = (IppLZOState_8u*)ippsMalloc_8u(lzo_struct_size);
+    if (p_lzo_state == NULL)
+        return 0;
+    ipp_status = ippsEncodeLZOInit_8u((opt_level>50)? IppLZO1XMT:IppLZO1XST, (Ipp32u)block_size, p_lzo_state);
+    if (ipp_status != ippStsNoErr)
+            return 0;
+    switch(opt_cmd) {
+    case CMD_COMPRESS:
+        if ((p_in_buffer = ippsMalloc_8u((int)block_size)) == NULL)
+            return 0;
+        in_len = (Ipp32u)block_size;
+        if ((p_out_buffer = ippsMalloc_8u(MAX_COMPRESSED_SIZE((int)block_size))) == NULL)
+            return 0;
+        out_len = (Ipp32u)MAX_COMPRESSED_SIZE(block_size);
+        break;
+    case CMD_TEST:
+    case CMD_DECOMPRESS:
+        if ((p_in_buffer = ippsMalloc_8u((int)MAX_COMPRESSED_SIZE(block_size))) == NULL)
+            return 0;
+        in_len = (Ipp32u)MAX_COMPRESSED_SIZE(block_size);
+        if ((p_out_buffer = ippsMalloc_8u((int)block_size)) == NULL)
+            return 0;
+        out_len = (Ipp32u)block_size;
+        break;
+    }
+    return 1;
+}
+
+int ipp_lzo_get_method(header_t *h)
+{
+/* check method */
+    if (h->method == M_IPP)
+    {
+        if (h->level == 50) {
+            h->method_name = "IPPLZOST";
+        } else {
+            h->method_name = "IPPLZOMT";
+        }
+    }
+    else
+        return -1;      /* not a LZO method */
+    return 0;
+}
+
+void ipp_lzo_leave(const header_t *h)
+{
+    if (h == NULL) {
+        if (p_in_buffer != NULL) {
+            ippsFree(p_in_buffer);
+            p_in_buffer = NULL;
+            in_len = 0;
+        }
+        if (p_out_buffer != NULL) {
+            ippsFree(p_out_buffer);
+            p_out_buffer = NULL;
+            out_len = 0;
+        }
+        if (p_lzo_state != NULL) {
+            ippsFree(p_lzo_state);
+            p_lzo_state = NULL;
+        }
+    }
+}
+
+void ipp_lzo_init_compress_header(header_t *h)
+{
+    if (opt_checksum)
+    {
+        if (opt_crc32)
+        {
+            h->flags |= F_CRC32_D;
+            if (opt_checksum >= 2)
+                h->flags |= F_CRC32_C;
+        }
+        else
+        {
+            h->flags |= F_ADLER32_D;
+            if (opt_checksum >= 2)
+                h->flags |= F_ADLER32_C;
+        }
+    }
+}
+
+/*************************************************************************
+// compress a file
+**************************************************************************/
+
+lzo_bool ipp_lzo_compress(file_t *fip, file_t *fop, const header_t *h)
+{
+    IppStatus r;
+    Ipp8u *b1 = p_in_buffer;
+    Ipp8u *b2 = p_out_buffer;
+    lzo_uint32 src_len = 0;
+    lzo_uint dst_len = 0;
+    Ipp32u c_adler32 = ADLER32_INIT_VALUE, d_adler32 = ADLER32_INIT_VALUE;
+    Ipp32u c_crc32 = CRC32_INIT_VALUE, d_crc32 = CRC32_INIT_VALUE;
+    lzo_int len;
+    lzo_bool ok = 1;
+#if defined(WITH_IPP_LZO)
+    Ipp64u total_clocks = 0;
+    Ipp64u start;
+#endif
+
+    for (;;)
+    {
+        /* read a block */
+        len = read_buf(fip, b1, block_size);
+        src_len = (len > 0 ? len : 0);
+
+        /* write uncompressed block size */
+        write32(fop,src_len);
+
+        /* exit if last block */
+        if (src_len == 0)
+            break;
+
+        /* compute checksum of uncompressed block */
+#if defined(WITH_IPP_LZO)
+        start = ippGetCpuClocks();
+#endif
+        if (h->flags & F_ADLER32_D) {
+            d_adler32 = ADLER32_INIT_VALUE;
+            r = ippsAdler32_8u(b1, src_len, &d_adler32);
+        }
+        if (h->flags & F_CRC32_D) {
+            d_crc32 = CRC32_INIT_VALUE;
+            r = ippsCRC32_8u(b1, src_len, &d_crc32);
+        }
+#if defined(WITH_IPP_LZO)
+        total_clocks += ippGetCpuClocks() - start;
+#endif
+
+        x_filter(b1,src_len, h);
 
+        /* compress */
+#if defined(WITH_IPP_LZO)
+        start = ippGetCpuClocks();
+#endif
+        dst_len = MAX_BLOCK_SIZE;
+        r = ippsEncodeLZO_8u(b1, (Ipp32u)src_len, b2, (Ipp32u*)&dst_len, p_lzo_state);
+#if defined(WITH_IPP_LZO)
+        total_clocks += ippGetCpuClocks() - start;
+#endif
+#if 0
+        fprintf(stderr, "%ld %ld %ld\n", (long)src_len, (long)dst_len, (long)block2.size);
+#endif
+        if (r != ippStsNoErr)
+            fatal(fip,"Internal error - compression failed");
+        /* write compressed block size */
+        if (dst_len < src_len)
+            write32(fop,dst_len);
+        else
+            write32(fop,src_len);
+
+        /* write checksum of uncompressed block */
+        if (h->flags & F_ADLER32_D)
+            write32(fop,d_adler32);
+        if (h->flags & F_CRC32_D)
+            write32(fop,d_crc32);
+
+        /* write checksum of compressed block */
+        if (dst_len < src_len && (h->flags & F_ADLER32_C))
+        {
+            c_adler32 = ADLER32_INIT_VALUE;
+            r = ippsAdler32_8u(b2, (int)dst_len, &c_adler32);
+            write32(fop,c_adler32);
+        }
+        if (dst_len < src_len && (h->flags & F_CRC32_C))
+        {
+            c_crc32 = CRC32_INIT_VALUE;
+            r = ippsCRC32_8u(b2, (int)dst_len, &c_crc32);
+            write32(fop,c_crc32);
+        }
+
+        /* write compressed block data */
+        if (dst_len < src_len)
+            write_buf(fop,b2,dst_len);
+        else
+            write_buf(fop,b1,src_len);
+    }
+#if defined(WITH_IPP_LZO)
+    if(opt_show_clocks) {
+        printf( "total_clocks = %llu\n", total_clocks );
+    }
+#endif
+
+    return ok;
+}
+
+/*************************************************************************
+// decompress a file
+**************************************************************************/
+
+lzo_bool ipp_lzo_decompress(file_t *fip, file_t *fop,
+                        const header_t *h, lzo_bool skip)
+{
+    Ipp32u src_len, dst_len;
+    Ipp32u c_adler32 = ADLER32_INIT_VALUE, d_adler32 = ADLER32_INIT_VALUE;
+    Ipp32u c_crc32 = CRC32_INIT_VALUE, d_crc32 = CRC32_INIT_VALUE;
+    lzo_bool ok = 1;
+    lzo_bool use_seek;
+    Ipp8u *b1 = p_out_buffer;
+    Ipp8u *b2 = p_in_buffer;
+    IppStatus status;
+#if defined(WITH_IPP_LZO)
+    Ipp64u total_clocks = 0;
+    Ipp64u start;
+#endif
+
+    use_seek = skip || opt_cmd == CMD_LIST || opt_cmd == CMD_LS ||
+                       opt_cmd == CMD_INFO;
+
+    for (;;)
+    {
+        Ipp8u *dst;
+
+        /* read uncompressed block size */
+        read32(fip,&dst_len);
+
+        /* exit if last block */
+        if (dst_len == 0)
+            break;
+
+        /* error if split file */
+        if (dst_len == 0xffffffffUL)
+        {
+            /* should not happen - not yet implemented */
+            error(fip,"this file is a split " PACKAGE " file");
+            ok = 0; break;
+        }
+
+        if (dst_len > MAX_BLOCK_SIZE)
+        {
+            error(fip, PACKAGE " file corrupted");
+            ok = 0; break;
+        }
+
+        /* read compressed block size */
+        read32(fip,&src_len);
+        if (src_len <= 0 || src_len > dst_len)
+        {
+            error(fip, PACKAGE " file corrupted");
+            ok = 0; break;
+        }
+
+        if (dst_len > BLOCK_SIZE)
+        {
+            fatal(fip,"block size too small -- recompile " PACKAGE);
+            ok = 0; break;
+        }
+        if (dst_len > block_size)
+        {
+            /* should not happen - not yet implemented */
+            fatal(fip,"block size too small -- use option `--blocksize'");
+            ok = 0; break;
+        }
+
+        /* read checksum of uncompressed block */
+        if (h->flags & F_ADLER32_D)
+            read32(fip,&d_adler32);
+        if (h->flags & F_CRC32_D)
+            read32(fip,&d_crc32);
+
+        /* read checksum of compressed block */
+        if (h->flags & F_ADLER32_C)
+        {
+            if (src_len < dst_len)
+                read32(fip,&c_adler32);
+            else
+            {
+                assert(h->flags & F_ADLER32_D);
+                c_adler32 = d_adler32;
+            }
+        }
+        if (h->flags & F_CRC32_C)
+        {
+            if (src_len < dst_len)
+                read32(fip,&c_crc32);
+            else
+            {
+                assert(h->flags & F_CRC32_D);
+                c_crc32 = d_crc32;
+            }
+        }
+
+        /* read the block */
+        if (use_seek && fip->fd != STDIN_FILENO)
+        {
+            if (lseek(fip->fd, src_len, SEEK_CUR) == -1)
+                read_error(fip);
+        }
+        else
+        {
+            if (read_buf(fip, b1, src_len) != (lzo_int) src_len)
+                read_error(fip);
+        }
+
+        fip->bytes_processed += src_len;
+        if (use_seek)
+        {
+            fop->bytes_processed += dst_len;
+            continue;
+        }
+        /* assert(src_len >= MAX_COMPRESSED_SIZE(dst_len)); */
+
+        /* verify checksum of compressed block */
+        if (opt_checksum && (h->flags & F_ADLER32_C))
+        {
+            Ipp32u c = ADLER32_INIT_VALUE;
+            status = ippsAdler32_8u(b1, src_len, &c);
+            if (c != c_adler32 || status != ippStsNoErr)
+            {
+                error(fip,"Checksum error (" PACKAGE " file corrupted)");
+                ok = 0; break;
+            }
+        }
+        if (opt_checksum && (h->flags & F_CRC32_C))
+        {
+            Ipp32u c = CRC32_INIT_VALUE;
+            status = ippsCRC32_8u(b1, src_len, &c);
+            if (c != c_crc32 || status != ippStsNoErr)
+            {
+                error(fip,"Checksum error (" PACKAGE " file corrupted)");
+                ok = 0; break;
+            }
+        }
+
+        if (src_len < dst_len)
+        {
+            Ipp32u d = dst_len;
+
+            /* decompress */
+#if defined(WITH_IPP_LZO)
+            start = ippGetCpuClocks();
+#endif
+            if (opt_decompress_safe)
+                status = ippsDecodeLZOSafe_8u(b1, src_len, b2, &dst_len);
+            else
+                status = ippsDecodeLZO_8u(b1, src_len, b2, &dst_len);
+#if defined(WITH_IPP_LZO)
+            total_clocks += ippGetCpuClocks() - start;
+#endif
+            if (status != ippStsNoErr || dst_len != d)
+            {
+                error(fip,"Compressed data violation");
+#if 0
+                fprintf(stderr,"%d %ld %ld\n", r, (long)dst_len, (long)d);
+#endif
+                ok = 0; break;
+            }
+            dst = b2;
+        }
+        else
+        {
+            assert(dst_len == src_len);
+            dst = b1;
+        }
+
+        /* x_filter(dst,dst_len,h); */
+
+        /* verify checksum of uncompressed block */
+#if defined(WITH_IPP_LZO)
+        start = ippGetCpuClocks();
+#endif
+        if (opt_checksum && (h->flags & F_ADLER32_D))
+        {
+            Ipp32u c = ADLER32_INIT_VALUE;
+            status = ippsAdler32_8u(dst, dst_len, &c);
+            if (c != d_adler32 || status != ippStsNoErr)
+            {
+                error(fip,"Checksum error");
+                ok = 0; break;
+            }
+        }
+        if (opt_checksum && (h->flags & F_CRC32_D))
+        {
+            Ipp32u c = CRC32_INIT_VALUE;
+            status = ippsCRC32_8u(dst, dst_len, &c);
+            if (c != d_crc32 || status != ippStsNoErr)
+            {
+                error(fip,"Checksum error");
+                ok = 0; break;
+            }
+        }
+#if defined(WITH_IPP_LZO)
+        total_clocks += ippGetCpuClocks() - start;
+#endif
+
+        /* write uncompressed block data */
+        write_buf(fop,dst,dst_len);
+        fop->bytes_processed += dst_len;
+    }
+#if defined(WITH_IPP_LZO)
+    if(opt_show_clocks) {
+        printf( "total_clocks = %llu\n", total_clocks );
+    }
+#endif
+
+    return ok;
+}
+#endif /* WITH_IPP_LZO */
 /*
 vi:ts=4:et
 */
